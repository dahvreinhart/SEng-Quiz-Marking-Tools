# Dahv Reinhart - V00735279
# SEng265 - Assignment 3
# 'Quiz Library' - Provides functions used to interpret a quiz_log_file generated by the Connex quiz system
# Due Nov 28th, 2015

import libxml2
import sys

'''
purpose
	store the information from an answer element
'''
class Answer:
	def __init__(self, index, path, result, answer, time):
		self.index = index
		self.path = path
		self.result = result
		self.answer = answer
		self.time = time

'''
purpose
	Store the information from a display element.
'''
class Display:
	def __init__(self, index, path, time):
		self.index = index
		self.path = path
		self.time = time

'''
purpose
	Extract the information from log_file and return it as a list
	of answer and display objects.
preconditions
	log_file is the name of a legal, readable quiz log XML file
'''
def load_quiz_log(log_file):
	quiz = libxml2.parseFile(log_file)
	context = quiz.xpathNewContext()  #initiate the XML tree and get the root node for the quiz log file
	root = quiz.getRootElement()
	itemAD = root.children

	itemsAD = []
	while itemAD is not None:
		if itemAD.name == "answer":  #need to create an 'Answer' object now
			detailsA = itemAD.children
			while detailsA is not None:
				if detailsA.name == "index":  #store values of object fields read in the XML file
					indexA = detailsA.content
					if indexA == "":
						indexA = None #if field is empty, return 'None'
				elif detailsA.name == "path":
					pathA = detailsA.content
					if pathA == "":
						pathA = None
				elif detailsA.name == "result":
					resultA = detailsA.content
					if resultA == "":
						resultA = None
				elif detailsA.name == "answer":
					answerA = detailsA.content
					if answerA == "":
						answerA = None
				elif detailsA.name == "time":
					timeA = detailsA.content
					if timeA == "":
						timeA = None

				detailsA = detailsA.next

			temp = Answer(indexA, pathA, resultA, answerA, timeA) 
			itemsAD.append(temp) #create the 'Answer' element and add it to the growing log_list

		elif itemAD.name == "display": #need to create a 'Display' object now
			detailsD = itemAD.children
			while detailsD is not None:
				if detailsD.name == "index":
					indexD = detailsD.content
					if indexA == "":
						indexA = None
				elif detailsD.name == "path":
					pathD = detailsD.content
					if pathA == "":
						pathA = None
				elif detailsD.name == "time":
					timeD = detailsD.content
					if timeA == "":
						timeA = None

				detailsD = detailsD.next

			temp2 = Display(indexD, pathD, timeD)
			itemsAD.append(temp2) #create the 'Display' object and add it to the growing log_list

		itemAD = itemAD.next

	return itemsAD

'''
purpose
	Return the number of distinct questions in log_list.
preconditions
	log_list was returned by load_quiz_log
'''
def compute_question_count(log_list):
	counter = 0
	for x in log_list:
		if isinstance(x, Display): 
			return counter
		counter += 1

# After going through the initially loaded dummy 'Answer' objects, the first 'Display' object encountered
# will signal the beginning of the marked quiz. Thus, the number of dummy 'Answer' objects scanned before
# then will always be equal to the number of questions in the log_file.


'''
purpose
	Extract the list of marks.
	For each index value, use the result from the last non-empty answer,
	or 0 if there are no non-empty results.
preconditions
	log_list was returned by load_quiz_log
'''
def compute_mark_list(log_list):
	markList = []
	counter = 0
	for x in log_list:
		if isinstance(x, Display): #get the number of questions 
			break
		counter += 1
		
	markList = range(counter) #init list to be equal to the question number
	
	for x in log_list:
		if isinstance(x, Answer): #only 'Answer' objects have a 'mark' field
			if x.result is None:
				markList[int(x.index)] = 0 #if student hasnt answered, no marks given
			else:
				markList[int(x.index)] = int(x.result) #insert the mark at the correct list location


	return markList





